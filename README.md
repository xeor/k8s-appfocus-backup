# karb - k8s App-controlled Restore & Backup

NOTE: This is just an experiment for now...

## Intro

There are many backup-solutions for kubernetes, but many of them are overly complicated.
karb tries to solve the backup/restore problem another way letting the app itself do the backup/restore
by small scripts in pod annotations.

Don't use this solution if you want something rock solid.
The solution is mostly tailered for small clusters and home-labs.

* Why use this
  * You want to use the application to backup itself
  * You don't want to depend on s3 or similar services to do restore
  * You want an easy way to restore the service, also outside kubernetes

* Why not
  * You want something battletested
  * You need backup of more kubernetes contexts, not only the data

## How it works

karb is an operator that looks for pods with special annotations.
* It will inject a backup-volume (from nfs) into your container on `/karb-data`
* It will execute a command (or tiny shell script) defined in the annotations on a schedule. You are supposed to do the backup here and put it on `/karb-data`
* When you start the pod, we will
  * Create a duplicate of your main container as an init container. We will run the restore-exec annotation in it
  * You are supposed to check if restore is needed, if it is, restore. You also have the `/karb-data` volume. Main container won't start before we are done.
* `/karb-data` will be mounted based on the backup-name defined. No pod-id or stuff like that. This is by design.

Using this pattern, we can run the apps own backup command (like pgdump, somecli backup, ...) on a schedule. Then, when the container starts, you can check if backup is needed and it will automatically restore.

Since the backup volume is defined based on a name you choose, you can very easiely reinstall the whole cluster and the restores will be done automatically for you because your restore scripts have access to your newest backup, runs in the init container, and have the content of your app and it's volumes.

## Security

The application container itself have access to the backups. It's trivial for someone with access inside the container to also delete the backup. Make sure this is not your only backup, or use another system to backup the artifacts generated by karb.

There are multiple security functions in place to make sure nothing bad happens
* The serviceaccount karb uses gets minimal access
  * List and watch for new namespaces globally
  * Access in namespaces defined in `config.namespaces`
    * get pods
    * list pods
    * watch pods - To see new pods
    * patch pods - Needed to add backup volume and restore init container
    * exec in pods - Needed to run backup job on a schedule
    * create events - To log error messages and status
* Default security policy for the operator
  * allowPrivilegeEscalation: false
  * capabilities, drop ALL
  * readOnlyRootFilesystem: true
  * runAsNonRoot: true
  * runas user/group: nobody
  * seccompProfile: RuntimeDefault

## Installation and configuration

The easiest and best way to install is to use helm.
You would also need a running cert-manager inside your cluster because we use that to create a self-signed certificate that is used for the admission-controller. Without this we can't have a trusted certificate for the kubernetes api to talk to us.

helm upgrade --install --create-namespace karb helm -f values.yaml --namespace karb

## Monitoring

If configured, we enable scraping of some data from the operator using a ServiceMonitor.



## Spec

Here is a heavely commented example-pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example
  annotations:

    # Will be the subfolder of your backup volume. If you have configured
    # the operator to use path `/data/backup`, it will become `/data/backup/test`
    # in this case. Default is "default" if this annotation is left out.
    karb.boa.nu/backup-name: "test"

    # What container to run backup commands in and base the init container on.
    # It's important that this is the app-container itself. If left out
    # and there is only one container, we will use that. If there are more than one
    # and this is not defined, you will get an error.
    karb.boa.nu/container-name: "my-container"

    # Currently only how many seconds we should sleep before doing the next backup.
    karb.boa.nu/backup-schedule: "100"

    # What shell should we run the backup command in. If you want to run a shell-script
    # you should define it as "/bin/sh -c", which is the default if undefined
    karb.boa.nu/backup-exec-shell: "/bin/sh -c"

    # Script or command to run when doing backup. This command will be executed
    # inside the running app-container. You should put your backup in /karb-data
    karb.boa.nu/backup-exec: |
      date >> /karb-data/test

    # Same concept as karb.boa.nu/backup-exec-shell
    karb.boa.nu/restore-exec-shell: "/bin/sh -c"

    # Command to run in the init-container when pod is starting.
    # It is important that you check if you really want to do a restore before
    # you do the restore. That, and the restore itself is done here.
    karb.boa.nu/restore-exec: |
      if [ -f "/karb-data/test"]; then
        cp /karb-data/test /etc/test
        echo restored
        exit 0
      fi
      echo "not restoring"

spec:
  containers:
    - name: my-container
      image: busybox
      command: ["sh", "-c", "echo 'starting to sleep' && sleep 3600"]

  # If you want a custom restorer, instead of a "clone" of your main container
  # you can create an initContainer with the name "karb-restorer". If that exists
  # we will use that instead of creating it.
  # initContainers

```
